<?php
// $Id$

/**
 * @file
 * Implements entity hooks and classes to allow for caching of core entities.
 */

/**
 * Implement hook_entity_info_alter();
 */
function entitycache_entity_info_alter(&$entity_info) {
  $entity_info['node']['controller class'] = 'EntityCacheNodeController';
  $entity_info['node']['cacheable'] = FALSE;
  $entity_info['node']['entity cache'] = TRUE;
  $entity_info['taxonomy_term']['controller class'] = 'EntityCacheTaxonomyTermController';
  $entity_info['taxonomy_term']['cacheable'] = FALSE;
  $entity_info['taxonomy_term']['entity cache'] = TRUE;
  $entity_info['comment']['controller class'] = 'EntityCacheCommentController';
  $entity_info['comment']['cacheable'] = FALSE;
  $entity_info['comment']['entity cache'] = TRUE;
}

/**
 * Controller class for nodes.
 *
 * This extends the EntityCacheBaseController class, adding required
 * special handling for node objects.
 */
class EntityCacheNodeController extends EntityCacheBaseController {
  function attachLoad(&$nodes) {
    NodeController::attachLoad($nodes);
  }
  function buildQuery(){
    NodeController::buildQuery();
  }
}

/**
 * Controller class for taxonomy terms.
 *
 * Currently an exact copy of TaxonomyTermController.
 */
class EntityCacheTaxonomyTermController extends EntityCacheBaseController {
  protected $type;
  public function load($ids = array(), $conditions = array()) {
    return TaxonomyTermController::load($ids, $conditions);
  }

  protected function buildQuery() {
    TaxonomyTermController::buildQuery();
  }

  protected function cacheGet($ids) {
    return TaxonomyTermController::cacheGet($ids);
  }
}

/**
 * Controller class for comments.
 *
 * Currently a direct copy of CommentController.
 */
class EntityCacheCommentController extends EntityCacheBaseController {
  protected function buildQuery() {
    CommentController::buildQuery();
  }

  protected function attachLoad(&$comments) {
    CommentController::attachLoad($comments);
  }
}

/**
 *  Set up a base controller to allow for cache_get_multiple() and cache_set().
 */
class EntityCacheBaseController extends DrupalDefaultEntityController {

  public function load($ids = array(), $conditions = array()) {
    $this->ids = $ids;
    $this->conditions = $conditions;

    $entities = array();
    $cached_entities = array();
    $queried_entities = array();

    // Revisions are not statically cached, and require a different query to
    // other conditions, so separate the revision id into its own variable.
    if ($this->revisionKey && isset($this->conditions[$this->revisionKey])) {
      $this->revisionId = $this->conditions[$this->revisionKey];
      unset($this->conditions[$this->revisionKey]);
    }
    else {
      $this->revisionId = FALSE;
    }

    // Create a new variable which is either a prepared version of the $ids
    // array for later comparison with the entity cache, or FALSE if no $ids
    // were passed. The $ids array is reduced as items are loaded from cache,
    // and we need to know if it's empty for this reason to avoid querying the
    // database when all requested entities are loaded from cache.
    $passed_ids = !empty($this->ids) ? array_flip($this->ids) : FALSE;
    // Try to load entities from the static cache, if the entity type supports
    // static caching.
    if ($this->cache) {
      $entities = $this->cacheGet($this->ids, $this->conditions);
      // If any entities were loaded, remove them from the ids still to load.
      if ($passed_ids) {
        $this->ids = array_keys(array_diff_key($passed_ids, $entities));
      }

      // Attempt to load any remaining entities from the persistent cache.
      if ($this->ids && !$this->conditions) {
        $cached = cache_get_multiple($this->ids, 'cache_entity_' . $this->entityType);
        foreach ($cached as $item) {
          $cached_entities[$item->cid] = $item->data;
        }
        if ($cached) {
          $this->ids = array_diff($this->ids, array_keys($cached_entities));
        }
      }
    }

    // Load any remaining entities from the database. This is the case if $ids
    // is set to FALSE (so we load all entities), if there are any ids left to
    // load, if loading a revision, or if $conditions was passed without $ids.
    if ($this->ids === FALSE || $this->ids || $this->revisionId || ($this->conditions && !$passed_ids)) {
      // Build the query.
      $this->buildQuery();
      $queried_entities = $this->query
        ->execute()
        ->fetchAllAssoc($this->idKey);
    }

    // Pass all entities loaded from the database through $this->attachLoad(),
    // which attaches fields (if supported by the entity type) and calls the
    // entity type specific load callback, for example hook_node_load().
    if (!empty($queried_entities)) {
      $this->attachLoad($queried_entities);
      $entities += $queried_entities;
    }

    if ($this->cache && !empty($queried_entities)) {
      // Add entities to the cache if we are not loading a revision.
      if (!$this->revisionId) {
        foreach ($queried_entities as $item) {
          cache_set($item->{$this->idKey}, $item, 'cache_entity_' . $this->entityType);
        }
      }
    }
    $new_entities = $queried_entities + $cached_entities;

    if (!empty($new_entities)) {
      $this->attachAfterLoad($new_entities);
      if (!$this->revisionId) {
        $this->cacheSet($new_entities);
      }
      $entities += $cached_entities;
    }
    // Ensure that the returned array is ordered the same as the original
    // $ids array if this was passed in and remove any invalid ids.
    if ($passed_ids) {
      // Remove any invalid ids from the array.
      $passed_ids = array_intersect_key($passed_ids, $entities);
      foreach ($entities as $entity) {
        $passed_ids[$entity->{$this->idKey}] = $entity;
      }
      $entities = $passed_ids;
    }
    return $entities;
  }

  /**
   * Allow modules to implement uncached entity hooks.
   *
   * Adds an additional hook_entitycache_$type_load() for modules which need
   * to add data to objects during the request which can't be cached.
   * @see entitycache_entitycache_node_load().
   */
  protected function attachAfterLoad($new_entities) {
    foreach (module_implements('entitycache_' . $this->entityType . '_load') as $module) {
      $function = $module . '_entitycache_' . $this->entityType . '_load';
      $function($new_entities);
    }
  }
}

/**
 * Helper function to list all supported core entities.
 *
 * @return
 *   An array of core entities.
 */
function entitycache_supported_entities() {
  return array('node', 'comment', 'taxonomy_term');
}

/**
 * Implement hook_entity_insert().
 */
function entitycache_entity_insert($entity, $type) {
  // It is possible for other _insert() hooks to load an entity before it has
  // been properly saved, for example file_field_insert(). This may cause
  // an incomplete entity to be cached, since hooks which run after the one
  // loading the entity do not have a chance to run. Therefore ensure the cache
  // is always cleared when inserting new entities.
  // Since hook_entity_insert() runs last, there's a good chance of acting
  // after other modules are finished loading.
  $info = entity_get_info($type);
  list($id) = entity_extract_ids($type, $entity);
  if (!empty($info['entity cache'])) {
    cache_clear_all($id, 'cache_entity_' . $type);
  }
}

/**
 * Implement hook_entity_update().
 */
function entitycache_entity_update($entity, $type) {
  // It is possible for other _update() hooks to load an entity before it has
  // been properly saved, for example file_field_update(). This may cause
  // an incomplete entity to be cached, since hooks which run after the one
  // loading the entity do not have a chance to run. Therefore ensure the cache
  // is always cleared when updating entities.
  // Since hook_entity_insert() runs last, there's a good chance of acting
  // after other modules are finished loading.
  $info = entity_get_info($type);
  list($id) = entity_extract_ids($type, $entity);
  if (!empty($info['entity cache'])) {
    cache_clear_all($id, 'cache_entity_' . $type);
  }
}

/**
 * Implement hook_entitycache_node_load().
 *
 * This forces book information to be added on each request, to avoid expensive
 * cache clears.
 */
function book_entitycache_node_load($nodes) {
  book_node_load($nodes, array());
}

/**
 * Implement hook_entitycache_node_load().
 *
 * This forces poll information to be loaded on each request, since it loads
 * user-specific information during the request.
 */
function poll_entitycache_node_load($nodes) {
  poll_load($nodes);
}

/**
 * Implement hook_node_delete().
 */
function entitycache_node_delete($node) {
  cache_clear_all($node->nid, 'cache_entity_node');
}

/**
 * Implement hook_taxonomy_term_delete().
 */
function entitycache_taxonomy_term_delete($term) {
  cache_clear_all($term->tid, 'cache_entity_taxonomy_term');
}


/**
 * Implement hook_comment_delete().
 */
function entitycache_comment_delete($comment) {
  cache_clear_all($comment->cid, 'entity_cache_comment');
  cache_clear_all($comment->nid, 'entity_cache_node');
}

/**
 * Implement hook_comment_insert().
 */
function hook_comment_insert($comment) {
  cache_clear_all($comment->nid, 'entity_cache_node');
}

/**
 * Implement hook_comment_update().
 */
function entitycache_comment_update($comment) {
  cache_clear_all($comment->nid, 'entity_cache_node');
}

/**
 * Implement hook_comment_publish().
 *
 * @todo: core should not call this hook outside of a comment_save().
 */
function entitycache_comment_publish($comment) {
  cache_clear_all($comment->cid, 'entity_cache_comment');
}

/**
 * Implement hook_comment_unpublish().
 *
 * @todo: core should not call this hook outside of a comment_save().
 */
function entitycache_comment_unpublish($comment) {
  cache_clear_all($comment->cid, 'entity_cache_comment');
}
